'use strict';

(function () {
  angular.module('app', ['app.core', 'app.services', 'app.resources', 'app.modals', 'app.filters',

  /*
   * Feature areas
   */

  'app.admin.panel', 'app.admin.dashboard', 'app.manager.dashboard', 'app.kitchen.orders', 'app.auth', 'app.layout']).config(function (localStorageServiceProvider, $anchorScrollProvider, ngDialogProvider, $httpProvider) {
    localStorageServiceProvider.setPrefix('YOKI-CRM').setStorageType('localStorage').setNotify(true, true);

    ngDialogProvider.setDefaults({
      showClose: true
    });

    $httpProvider.interceptors.push('apiInterceptor');
    $anchorScrollProvider.disableAutoScrolling();

    $httpProvider.defaults.useXDomain = true;
    $httpProvider.defaults.headers.common['X-Requested-With'] = 'XMLHttpRequest';
    $httpProvider.defaults.headers.post['Content-Type'] = 'application/json';
    $httpProvider.defaults.headers.post['Accept'] = 'application/json';
  }).run(function ($rootScope, $location, user, USER_ROLES, helpers) {
    $rootScope.location = $location;
    $rootScope.go = function (path) {
      $location.path(path);
    };

    $rootScope.defaultRedirect = function () {
      if (helpers.findString(user.roles(), USER_ROLES.admin)) {
        $location.path('/admin/dashboard');
        return;
      }

      if (helpers.findString(user.roles(), USER_ROLES.manager)) {
        $location.path('/manager/dashboard');
        return;
      }

      if (helpers.findString(user.roles(), USER_ROLES.kitchen)) {
        $location.path('/kitchen/orders');
        return;
      }
    };
  });
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.layout', []);
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.filters', []);
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.resources', []);
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.core', [
  /**
   * Angular modules
   */

  'ngAnimate', 'ngResource', 'ngRoute', 'ngSanitize', 'ngLocale',

  /**
   * 3rd Party modules
   */

  'ngDialog', 'LocalStorageModule', 'angular-jwt', 'templates', 'ngplus', '720kb.datepicker', 'ui.mask', 'angular-click-outside',

  /**
   * Reusable blocks
   */

  'blocks.helpers', 'blocks.exception', 'blocks.logger', 'blocks.router', 'blocks.splash', 'blocks.edit-field', 'blocks.refresh-btn', 'blocks.image-upload', 'blocks.validator', 'blocks.dish-switch']);
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.modals', []);
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.services', []);
})();
'use strict';

(function () {
    'use strict';

    angular.module('blocks.exception', ['blocks.logger']);
})();
'use strict';

(function () {
    'use strict';

    angular.module('blocks.logger', []);
})();
'use strict';

(function () {
  'use strict';

  angular.module('blocks.dish-switch', []);
})();
'use strict';

(function () {
  'use strict';

  angular.module('blocks.splash', []);
})();
'use strict';

(function () {
    'use strict';

    angular.module('blocks.router', ['ngRoute', 'blocks.logger']);
})();
'use strict';

(function () {
  'use strict';

  angular.module('blocks.refresh-btn', []);
})();
'use strict';

(function () {
  'use strict';

  angular.module('blocks.validator', []);
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.auth', []);
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.admin.dashboard', []);
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.admin.panel', []);
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.kitchen.orders', []);
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.manager.dashboard', []);
})();
'use strict';

angular.module("ngLocale", [], ["$provide", function ($provide) {
  var PLURAL_CATEGORY = {
    ZERO: "zero",
    ONE: "one",
    TWO: "two",
    FEW: "few",
    MANY: "many",
    OTHER: "other"
  };

  function getDecimals(n) {
    n = n + '';
    var i = n.indexOf('.');
    return i == -1 ? 0 : n.length - i - 1;
  }

  function getVF(n, opt_precision) {
    var v = opt_precision;

    if (undefined === v) {
      v = Math.min(getDecimals(n), 3);
    }

    var base = Math.pow(10, v);
    var f = (n * base | 0) % base;
    return { v: v, f: f };
  }

  $provide.value("$locale", {
    "DATETIME_FORMATS": {
      "AMPMS": ["AM", "PM"],
      "DAY": ["воскресенье", "понедельник", "вторник", "среда", "четверг", "пятница", "суббота"],
      "ERANAMES": ["до н. э.", "н. э."],
      "ERAS": ["до н. э.", "н. э."],
      "FIRSTDAYOFWEEK": 0,
      "MONTH": ["января", "февраля", "марта", "апреля", "мая", "июня", "июля", "августа", "сентября", "октября", "ноября", "декабря"],
      "SHORTDAY": ["вс", "пн", "вт", "ср", "чт", "пт", "сб"],
      "SHORTMONTH": ["янв.", "февр.", "марта", "апр.", "мая", "июня", "июля", "авг.", "сент.", "окт.", "нояб.", "дек."],
      "STANDALONEMONTH": ["январь", "февраль", "март", "апрель", "май", "июнь", "июль", "август", "сентябрь", "октябрь", "ноябрь", "декабрь"],
      "WEEKENDRANGE": [5, 6],
      "fullDate": "EEEE, d MMMM y 'г'.",
      "longDate": "d MMMM y 'г'.",
      "medium": "d MMM y 'г'. HH:mm:ss",
      "mediumDate": "d MMM y 'г'.",
      "mediumTime": "HH:mm:ss",
      "short": "dd.MM.yy HH:mm",
      "shortDate": "dd.MM.yy",
      "shortTime": "HH:mm"
    },
    "NUMBER_FORMATS": {
      "CURRENCY_SYM": "₴",
      "DECIMAL_SEP": ",",
      "GROUP_SEP": " ",
      "PATTERNS": [{
        "gSize": 3,
        "lgSize": 3,
        "maxFrac": 3,
        "minFrac": 0,
        "minInt": 1,
        "negPre": "-",
        "negSuf": "",
        "posPre": "",
        "posSuf": ""
      }, {
        "gSize": 3,
        "lgSize": 3,
        "maxFrac": 2,
        "minFrac": 2,
        "minInt": 1,
        "negPre": "-",
        "negSuf": " ¤",
        "posPre": "",
        "posSuf": " ¤"
      }]
    },
    "id": "ru-ua",
    "localeID": "ru_UA",
    "pluralCat": function pluralCat(n, opt_precision) {
      var i = n | 0;
      var vf = getVF(n, opt_precision);
      if (vf.v == 0 && i % 10 == 1 && i % 100 != 11) {
        return PLURAL_CATEGORY.ONE;
      }
      if (vf.v == 0 && i % 10 >= 2 && i % 10 <= 4 && (i % 100 < 12 || i % 100 > 14)) {
        return PLURAL_CATEGORY.FEW;
      }
      if (vf.v == 0 && i % 10 == 0 || vf.v == 0 && i % 10 >= 5 && i % 10 <= 9 || vf.v == 0 && i % 100 >= 11 && i % 100 <= 14) {
        return PLURAL_CATEGORY.MANY;
      }
      return PLURAL_CATEGORY.OTHER;
    }
  });
}]);
'use strict';

(function () {
  'use strict';

  angular.module('app.layout').controller('Header', Header);

  Header.$inject = ['orderHistoryIntervalModal', 'managerOrderDetailModal', 'helpers', 'USER_ROLES', 'user'];

  function Header(intervalModal, orderDetailModal, helpers, USER_ROLES, user) {
    var vm = this;

    vm.roleName = getRoleName();
    vm.orderHistory = intervalModal.show;
    vm.createNewOrder = showModalOrder;

    ////////////////

    function getRoleName() {
      var result = 'адміністратор',
          roles = user.roles();

      if (helpers.findString(roles, USER_ROLES.manager)) {
        result = 'менеджер';
      }

      if (helpers.findString(roles, USER_ROLES.kitchen)) {
        result = 'кухня';
      }

      return result;
    }

    function showModalOrder() {
      orderDetailModal.scope.createEnabled = true;
      orderDetailModal.show();
    }
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.layout').controller('Shell', Shell);

  Shell.$inject = ['$timeout', '$rootScope', 'APP_EVENTS', 'user', 'dataservice'];

  function Shell($timeout, $rootScope, APP_EVENTS, user, dataservice) {
    var vm = this;

    vm.showSplash = false;
    vm.user = user.info();
    vm.isAdmin = user.isAdmin();
    vm.isKitchen = user.isKitchen();
    vm.isManager = user.isManager();
    vm.logout = logout;

    activate();

    function activate() {
      // Using a resolver on all routes or dataservice.ready in every controller
      dataservice.ready().then(function () {
        hideSplash();
      });
    }

    function hideSplash() {
      $timeout(function () {
        vm.showSplash = false;
      }, 1000);
    }

    function logout() {
      user.logout();
    }

    // Если пользователь вошел в приложение
    $rootScope.$on(APP_EVENTS.userLogin, function () {
      vm.user = user.info();
      vm.isAdmin = user.isAdmin();
      vm.isKitchen = user.isKitchen();
      vm.isManager = user.isManager();
    });
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.filters').filter('firstLetter', firstLetter);

  function firstLetter() {
    return firstLetterFilter;

    ////////////////

    function firstLetterFilter(item) {
      return item.charAt(0).toUpperCase();
    }
  }
})();
'use strict';

(function () {
  angular.module('app.resources').factory('admin', admin);

  admin.$inject = ['$resource'];

  function admin($resource) {
    return $resource('/admin/:action/:data', {}, {
      'create': {
        method: 'POST',
        params: {
          action: 'create'
        }
      },
      'fetchAll': {
        method: 'GET',
        isArray: true,
        params: {
          action: 'getAll'
        }
      },
      'history': {
        method: 'GET',
        isArray: true,
        params: {
          action: 'getOrderHistory'
        }
      },
      'makeInCooking': {
        method: 'POST',
        params: {
          action: 'proceedToCooking'
        }
      },
      'passOrderToCourier': {
        method: 'POST',
        params: {
          action: 'passOrderToCourier'
        }
      },
      'courierOnPlace': {
        method: 'POST',
        params: {
          action: 'courierOnPlace'
        }
      }
    });
  }
})();
'use strict';

(function () {
  angular.module('app.resources').factory('auth', auth);

  auth.$inject = ['$resource'];

  function auth($resource) {
    return $resource('/auth/:action/:data', {}, {
      'login': {
        method: 'POST',
        params: {
          action: ''
        }
      }
    });
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.resources').factory('categories', categories);

  categories.$inject = ['$resource'];

  /* @ngInject */
  function categories($resource) {
    return $resource('/category/:action/:id', {}, {
      'fetchAll': {
        method: 'GET',
        isArray: true,
        params: {
          action: 'getAll'
        }
      },
      'fetchDishes': {
        method: 'GET',
        isArray: true,
        params: {
          action: 'getAllDishesFromCategory'
        }
      },
      'create': {
        method: 'POST',
        params: {
          action: 'create'
        }
      },
      'remove': {
        method: 'GET',
        params: {
          action: 'remove'
        }
      },
      'removeDish': {
        method: 'POST',
        params: {
          action: 'removeDishFromCategory'
        }
      }
    });
  }
})();
'use strict';

(function () {
  angular.module('app.resources').factory('courier', courier);

  courier.$inject = ['$resource'];

  function courier($resource) {
    return $resource('/courier/:action/:data', {}, {
      'fetchAll': {
        method: 'GET',
        isArray: true,
        params: {
          action: 'getAllCouriers'
        }
      }
    });
  }
})();
'use strict';

(function () {
  angular.module('app.resources').factory('dishes', dishes);

  dishes.$inject = ['$resource'];

  function dishes($resource) {
    return $resource('/dish/:action/:data', {}, {
      'create': {
        method: 'POST',
        params: {
          action: 'create'
        }
      },
      'update': {
        method: 'POST',
        params: {
          action: 'update'
        }
      },
      'activate': {
        method: 'POST',
        params: {
          action: 'activate'
        }
      },
      'deactivate': {
        method: 'POST',
        params: {
          action: 'deactivate'
        }
      }
    });
  }
})();
'use strict';

(function () {
  angular.module('app.resources').factory('images', images);

  images.$inject = ['$resource'];

  function images($resource) {
    return $resource('/images/:action/:data', {}, {
      'remove': {
        method: 'POST',
        params: {
          action: 'removeImages'
        }
      },
      'upload': {
        method: 'POST',
        transformRequest: angular.identity,
        headers: { 'Content-Type': undefined },
        params: {
          action: 'addImages'
        }
      }
    });
  }
})();
'use strict';

(function () {
  angular.module('app.resources').factory('kitchen', kitchen);

  kitchen.$inject = ['$resource'];

  function kitchen($resource) {
    return $resource('/kitchen/:action/:data', {}, {
      'fetchAll': {
        method: 'GET',
        isArray: true,
        params: {
          action: 'getOrders'
        }
      },
      'prepared': {
        method: 'POST',
        params: {
          action: 'orderPrepared'
        }
      },
      'notPrepared': {
        method: 'POST',
        params: {
          action: 'orderNotPrepared'
        }
      }
    });
  }
})();
'use strict';

(function () {
  angular.module('app.resources').factory('operator', operator);

  operator.$inject = ['$resource'];

  function operator($resource) {
    return $resource('/operator/:action/:data', {}, {
      'makeInProgress': {
        method: 'POST',
        params: {
          action: 'setOrderInProgress'
        }
      },
      'close': {
        method: 'POST',
        params: {
          action: 'closeOrder'
        }
      },
      'makeCall': {
        method: 'POST',
        params: {
          action: 'makeCall'
        }
      }
    });
  }
})();
'use strict';

(function () {
  angular.module('app.resources').factory('orders', orders);

  orders.$inject = ['$resource'];

  function orders($resource) {
    return $resource('/order/:action/:data', {}, {
      'create': {
        method: 'POST',
        params: {
          action: 'createOrder'
        }
      },
      'fetchAvailable': {
        method: 'GET',
        isArray: true,
        params: {
          action: 'getAvailableOrders'
        }
      },
      'fetchAll': {
        method: 'GET',
        isArray: true,
        params: {
          action: 'getAllOrders'
        }
      },
      'decline': {
        method: 'POST',
        params: {
          action: 'declineOrder'
        }
      },
      'update': {
        method: 'POST',
        params: {
          action: 'updateOrder'
        }
      },
      'getDishes': {
        method: 'POST',
        isArray: true,
        params: {
          action: 'getDishes'
        }
      }
    });
  }
})();
'use strict';

(function () {
  angular.module('app.core').factory('common', common);

  common.$inject = ['$q', '$rootScope', '$timeout'];

  function common($q, $rootScope, $timeout) {
    var service = {
      $broadcast: $broadcast,
      $emit: $emit,
      $q: $q,
      $timeout: $timeout
    };

    return service;

    function $broadcast() {
      return $rootScope.$broadcast.apply($rootScope, arguments);
    }

    function $emit() {
      return $rootScope.$emit.apply($rootScope, arguments);
    }
  }
})();
'use strict';

(function () {
  'use strict';

  /**
   * @description
   * Основная конфигурация приложения
   */

  var core = angular.module('app.core');

  var config = {
    appErrorPrefix: '[YOKI-CRM Error] ',
    appTitle: 'YOKI CRM',
    version: '1.0.0'
  };

  core.value('config', config);

  core.config(toastrConfig);
  core.config(configure);
  core.config(attachAuthToken);

  core.run(defaultRoute);
  core.run(secureRoutes);

  /* @ngInject */
  function toastrConfig(toastr) {
    toastr.options.timeOut = 3000;
    toastr.options.positionClass = 'toast-bottom-right';
  }

  configure.$inject = ['$logProvider', '$routeProvider', 'routehelperConfigProvider', 'exceptionHandlerProvider'];

  function configure($logProvider, $routeProvider, routehelperConfigProvider, exceptionHandlerProvider) {
    // turn debugging off/on (no info or warn)
    if ($logProvider.debugEnabled) {
      $logProvider.debugEnabled(true);
    }

    // Configure the common route provider
    routehelperConfigProvider.config.$routeProvider = $routeProvider;
    var resolveAlways = {
      /* @ngInject */
      ready: function ready(dataservice) {
        return dataservice.ready();
      }
    };

    routehelperConfigProvider.config.resolveAlways = resolveAlways;

    // Configure the common exception handler
    exceptionHandlerProvider.configure(config.appErrorPrefix);
  }

  defaultRoute.$inject = ['$rootScope', '$route', 'user'];

  function defaultRoute($rootScope, $route, user) {
    $rootScope.$on('$locationChangeStart', function (event) {
      var route = $route.routes[$rootScope.location.path()];

      // Если не найден роут, значит вычисляем $routeProvider.otherwise
      if (!route) {
        event.preventDefault();

        if (!user.isAuth()) {
          $rootScope.go('/auth');
        } else {
          $rootScope.defaultRedirect();
        }
      }
    });
  }

  secureRoutes.$inject = ['$rootScope', '$route', 'user', 'helpers', 'logger'];

  function secureRoutes($rootScope, $route, user, helpers, logger) {
    // Запрещаем прямой доступ к защищенным урлам
    $rootScope.$on('$locationChangeStart', function (event) {
      var route = $route.routes[$rootScope.location.path()];

      if (route.data && route.data.authorities) {
        var access = false;

        route.data.authorities.forEach(function (role) {
          if (helpers.findString(user.roles(), role)) {
            access = true;
          }
        });

        if (!access) {
          event.preventDefault();
          $rootScope.defaultRedirect();
          logger.error('Помилка доступу');
        }
      }
    });
  }

  attachAuthToken.$inject = ['ENV', '$httpProvider', 'jwtInterceptorProvider'];

  function attachAuthToken(ENV, $httpProvider, jwtInterceptorProvider) {
    jwtInterceptorProvider.tokenGetter = ['jwtHelper', '$http', 'user', 'storage', '$location', function (jwtHelper, $http, user, storage, $location) {
      var token = storage.get('token');

      if (angular.isDefined(token)) {
        if (jwtHelper.isTokenExpired(token)) {
          return $http({
            url: ENV.apiUrl + '/auth/refresh',
            skipAuthorization: false,
            method: 'POST',
            headers: {
              Authorization: 'Bearer ' + token
            }
          }).then(function (response) {
            var newToken = response.data.token;

            storage.set('token', newToken);
            return newToken;
          }, function () {
            user.logout();
          });
        } else {
          return token;
        }
      }
    }];

    $httpProvider.interceptors.push('jwtInterceptor');
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.core').constant('ENV', {
    "apiUrl": 'http://46.101.230.74:8080'
  }).constant('APP_EVENTS', {
    serverError: 'server-error',
    userLogin: 'user-enter',
    userLogout: 'user-logout',
    refreshPage: 'refresh-page',
    refreshPageDone: 'refresh-page-done'
  }).constant('USER_ROLES', {
    admin: 'ROLE_ADMINISTRATOR',
    manager: 'ROLE_OPERATOR',
    kitchen: 'ROLE_KITCHEN',
    guest: 'ROLE_GUEST'
  }).constant('toastr', toastr).constant('moment', moment);
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.core').factory('dataservice', dataservice);

  dataservice.$inject = ['$q', 'exception'];

  /* @ngInject */
  function dataservice($q, exception) {
    var isPrimed = false;
    var primePromise;

    var service = {
      ready: ready
    };

    return service;

    function prime() {
      // This function can only be called once.
      if (primePromise) {
        return primePromise;
      }

      primePromise = $q.when(true).then(success);
      return primePromise;

      function success() {
        isPrimed = true;
      }
    }

    function ready(nextPromises) {
      var readyPromise = primePromise || prime();

      return readyPromise.then(function () {
        return $q.all(nextPromises);
      }).catch(exception.catcher('"ready" function failed'));
    }
  }
})();
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

(function () {
  'use strict';

  angular.module('app.modals').factory('BaseModal', BaseModal);

  BaseModal.$inject = ['user'];

  function BaseModal(user) {
    var cache = [];

    var BaseModalClass = function () {
      /**
       * Базовый класс для модальных окон
       * @param name
       * @param events
       * @description содержит публичные свойства events, scope. Scope используется
       * для передачи в контроллер модального окна данных из внешнего scope.
       */

      function BaseModalClass(name, events) {
        _classCallCheck(this, BaseModalClass);

        this._subscribers = {};

        this.events = events || {};
        this.scope = {};

        cache.push(_defineProperty({}, name, this));
      }

      /**
       * Подписка на события в модальном окне
       * @param {String} eventName
       * @param {Function} cb
       */

      _createClass(BaseModalClass, [{
        key: 'on',
        value: function on(eventName, cb) {
          this._subscribers[eventName] = cb;
        }

        /**
         * Вызов всех подписчиков на переданное событие
         * @param {String} eventName
         * @param {Array} args
         */

      }, {
        key: 'emit',
        value: function emit(eventName) {
          var sub = this._subscribers[eventName];

          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          sub.apply(sub, args);
        }

        /**
         * Возврат модального окна из кеша если есть
         * @param {String} name
         * @returns {Object}
         */

      }], [{
        key: 'get',
        value: function get(name) {
          var result = {};

          cache.forEach(function (modal) {
            if (modal[name]) {
              result = modal[name];
            }
          });

          return result;
        }
      }, {
        key: 'getClassName',
        value: function getClassName() {
          return user.isManager() ? 'manager-modal' : '';
        }
      }]);

      return BaseModalClass;
    }();

    return BaseModalClass;
  }
})();
'use strict';

(function () {
  angular.module('app.services').factory('apiInterceptor', function ($rootScope, $q, ENV, exception) {
    return {
      request: function request(config) {
        config.uri = config.url;

        // Если запрос идет не к html/, то добавляем base url
        if (config.url.indexOf('html/', 0) == -1) {
          config.url = ENV.apiUrl + config.url;
        }

        return config;
      },
      requestError: function requestError(request) {
        return $q.reject(request);
      },
      responseError: function responseError(response) {
        if (response.status === 401 || response.status === 403) {
          exception.catcher('Помилка входу в систему')(response);
        } else {
          exception.catcher('XHR помилка для ' + response.config.uri)(response);
        }

        return $q.reject(response);
      }
    };
  });
})();
'use strict';

(function () {
    angular.module('app.services').factory('storage', storage);

    /**
     * @ngdoc service
     * @name storage
     * @module app.services
     *
     * @description
     * Более удобная обертка над внешним сервисом localStorageService
     */

    storage.$inject = ['localStorageService'];

    function storage(localStorageService) {
        return {
            set: function set(key, value) {
                localStorageService.set(key, value);
            },
            get: function get(key, defaultValue) {
                return localStorageService.get(key) || defaultValue;
            },
            remove: function remove(key) {
                localStorageService.remove(key);
            },
            setObject: function setObject(key, value) {
                localStorageService.set(key, JSON.stringify(value));
            },
            getObject: function getObject(key) {
                return JSON.parse(localStorageService.get(key)) || {};
            },
            getArray: function getArray(key) {
                return JSON.parse(localStorageService.get(key)) || [];
            }
        };
    }
})();
'use strict';

(function () {
  angular.module('app.services').factory('user', user);

  /**
   * @ngdoc service
   * @name user
   * @module app.services
   *
   * @description
   * Сервис который отвечает за авторизацию пользователей
   */

  user.$inject = ['$q', '$rootScope', 'APP_EVENTS', 'USER_ROLES', '$location', 'jwtHelper', 'helpers', 'auth', 'storage'];

  function user($q, $rootScope, APP_EVENTS, USER_ROLES, $location, jwtHelper, helpers, auth, storage) {
    var isAuthenticated = false;
    var service = {
      login: login,
      logout: logout,
      info: getInfo,
      roles: getRoles,
      isAdmin: isAdmin,
      isManager: isManager,
      isKitchen: isKitchen,
      isAuth: function isAuth() {
        return isAuthenticated;
      }
    };

    isAuth();

    return service;

    ////////////////

    function isAuth() {
      var token = storage.get('token');

      if (token) {
        isAuthenticated = true;
      } else {
        isAuthenticated = false;
      }
    }

    function login(form) {
      var deferred = $q.defer();

      auth.login(form, function (response) {
        if (exceptCourier(response.token)) {
          storage.set('token', response.token);
          isAuthenticated = true;
          $rootScope.$broadcast(APP_EVENTS.userLogin);

          deferred.resolve(response);
        } else {
          deferred.reject();
        }
      }, function (error) {
        deferred.reject(error);
      });

      return deferred.promise;
    }

    function logout() {
      isAuthenticated = false;
      storage.remove('token');

      $location.path('/auth');
    }

    function getInfo() {
      var token = storage.get('token');

      if (token) {
        return jwtHelper.decodeToken(token);
      }
    }

    function getRoles() {
      var info = getInfo();
      var result = [];

      if (info) {
        info.userRoles.forEach(function (role) {
          result.push(role.name);
        });
      } else {
        result.push(USER_ROLES.guest);
      }

      return result;
    }

    function isAdmin() {
      return isRole(USER_ROLES.admin);
    }

    function isManager() {
      return isRole(USER_ROLES.manager);
    }

    function isKitchen() {
      return isRole(USER_ROLES.kitchen);
    }

    function isRole(role) {
      var roles = getRoles();
      var result = false;

      if (roles) {
        if (helpers.findString(roles, role)) {
          result = true;
        }
      }

      return result;
    }

    function exceptCourier(token) {
      var info = jwtHelper.decodeToken(token);
      var result = true;

      info.userRoles.forEach(function (role) {
        if (role.name === 'ROLE_COURIER') {
          result = false;
        }
      });

      return result;
    }
  }
})();
'use strict';

// Include in index.html so that app level exceptions are handled.
// Exclude from testRunner.html which should run exactly what it wants to run
(function () {
  'use strict';

  angular.module('blocks.exception').provider('exceptionHandler', exceptionHandlerProvider).config(config);

  /**
   * Must configure the exception handling
   * @return {[type]}
   */
  function exceptionHandlerProvider() {
    /* jshint validthis:true */
    this.config = {
      appErrorPrefix: undefined
    };

    this.configure = function (appErrorPrefix) {
      this.config.appErrorPrefix = appErrorPrefix;
    };

    this.$get = function () {
      return { config: this.config };
    };
  }

  /**
   * Configure by setting an optional string value for appErrorPrefix.
   * Accessible via config.appErrorPrefix (via config value).
   * @param  {[type]} $provide
   * @return {[type]}
   * @ngInject
   */
  function config($provide) {
    $provide.decorator('$exceptionHandler', extendExceptionHandler);
  }

  /**
   * Extend the $exceptionHandler service to also display a toast.
   * @param  {Object} $delegate
   * @param  {Object} exceptionHandler
   * @param  {Object} logger
   * @return {Function} the decorated $exceptionHandler service
   */
  function extendExceptionHandler($delegate, exceptionHandler, logger) {
    return function (exception, cause) {
      var appErrorPrefix = exceptionHandler.config.appErrorPrefix || '';
      var errorData = { exception: exception, cause: cause };
      exception.message = appErrorPrefix + exception.message;
      $delegate(exception, cause);
      /**
       * Could add the error to a service's collection,
       * add errors to $rootScope, log errors to remote web server,
       * or log locally. Or throw hard. It is entirely up to you.
       * throw exception;
       *
       * @example
       *     throw { message: 'error message we added' };
       */
      logger.error(exception.message, errorData);
    };
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('blocks.exception').factory('exception', exception);

  /* @ngInject */
  function exception(logger) {
    var service = {
      catcher: catcher
    };

    return service;

    function catcher(message) {
      return function (reason) {
        logger.error(message, reason);
      };
    }
  }
})();
'use strict';

(function () {
  angular.module('blocks.helpers', []).factory('helpers', helpers);

  helpers.$inject = ['$filter'];

  function helpers($filter) {

    var service = {};

    /**
     * Возвращает новый массив разделенные на ряды, в каждом ряду будет sizeColumn колонок
     * Helpers.shapeArrayInRows([0,1,2,3], 3) => [[0,1,2],[3]]
     * @param {Array} array
     * @param {Integer} sizeColumn
     * @returns {Array}
     */

    service.shapeArrayInRows = function (array, sizeColumn) {
      var result = [];

      for (var i = 0; i < array.length; i += sizeColumn) {
        result.push(array.slice(i, i + sizeColumn));
      }

      return result;
    };

    /**
     * Выполняет поиск в массиве data, по переданному объекту conditions.
     * Пример объекта conditions = {key: value}
     * @param {Array} data
     * @param {Object} conditions
     * @returns {Object|Undefined}
     */

    service.searchByKey = function (data, conditions) {
      var keys = Object.keys(conditions);
      var result = void 0;

      data.forEach(function (row) {
        if (row[keys[0]] == conditions[keys[0]]) {
          result = row;
        }
      });

      return result;
    };

    service.searchIndex = function (data, conditions) {
      var keys = Object.keys(conditions);
      var index = void 0;

      for (var i = 0; i < data.length; i++) {
        if (data[i][keys[0]] == conditions[keys[0]]) {
          index = i;
        }
      }

      return index;
    };

    service.nextElementInArray = function (data, conditions) {
      var keys = Object.keys(conditions);
      var result = void 0;

      data.forEach(function (row, i, array) {
        if (row[keys[0]] == conditions[keys[0]]) {
          result = array[i + 1];
        }
      });

      return result;
    };

    service.prevElementInArray = function (data, conditions) {
      var keys = Object.keys(conditions);
      var result = void 0;

      data.forEach(function (row, i, array) {
        if (row[keys[0]] == conditions[keys[0]]) {
          result = array[i - 1];
        }
      });

      return result;
    };

    /**
     * Ищет переданную строку в массиве из строк
     * @param array
     * @param string
     * @returns {*}
     */

    service.findString = function (array, string) {
      var result = false;

      array.forEach(function (item) {
        if (item === string) {
          result = item;
        }
      });

      return result;
    };

    /**
     * Сортировка сущностей по id в порядке убывания
     * @param prev
     * @param next
     * @returns {number}
     */

    service.compareById = function (prev, next) {
      if (prev.id > next.id) {
        return -1;
      }

      if (prev.id < next.id) {
        return 1;
      }

      return 0;
    };

    /**
     * Фильтрация всех заказов по переданным статусам
     * @param {Array} orders
     * @param {Array} statuses
     * @returns {Array}
     */

    service.filterOrdersByStatus = function (orders, statuses) {
      var results = [];

      orders.forEach(function (order) {
        if (service.findString(statuses, order.status)) {
          results.push(order);
        }
      });

      return results;
    };

    /**
     * Подсчитывает сводную информацию о заказе
     * @param order
     * @returns {{price: number, count: number}}
     */

    service.calculateOrderInfo = function (order) {
      var result = {
        price: 0,
        count: 0
      };

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = order.dishes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var dish = _step.value;

          result.price += dish.dish.price * dish.quantity;
          result.count += dish.quantity;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return result;
    };

    /**
     * Получает текущую дату и возвращает объект
     * @returns {{yyyy: number, mm: number, dd: number}}
     */

    service.getDate = function () {
      var today = new Date();
      var dd = today.getDate();
      var mm = today.getMonth() + 1;
      var yyyy = today.getFullYear();

      if (dd < 10) {
        dd = '0' + dd;
      }

      if (mm < 10) {
        mm = '0' + mm;
      }

      var str = yyyy + '-' + mm + '-' + dd;

      return {
        yyyy: yyyy,
        mm: mm,
        dd: dd,
        str: str
      };
    };

    /**
     * Делит строку вида 23:59 и возвращает объект
     * @param str
     * @returns {{hours: string, minutes: string}}
     */

    service.getHourMinutes = function (str) {
      if (str) {
        return {
          hours: str.substr(0, 2),
          minutes: str.substr(2, 4)
        };
      }
    };

    /**
     * Возвращает из timestamp строку из 4 цифр HHmm
     * @param date
     * @returns {string}
     */

    service.parseDate = function (date) {
      var hhmm = $filter('date')(date, 'HHmm');
      var foo = service.getHourMinutes(hhmm);

      return '' + foo.hours + foo.minutes;
    };

    return service;
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('blocks.image-upload', []).directive('imageUpload', imageUpload);

  imageUpload.$inject = ['toastr', 'images', 'ENV', '$q'];

  function imageUpload(toastr, images, ENV, $q) {
    return {
      restrict: 'E',
      replace: true,
      scope: {},
      require: 'ngModel',
      templateUrl: 'html/blocks/image-upload/image-upload.html',
      link: function link(scope, element, attrs, ngModel) {
        scope.uploaded = false;
        scope.previewImages = [];
        scope.images = [];
        scope.removeImage = removeImage;
        scope.removePreview = removePreview;
        scope.fullPath = fullPath;

        scope.$watch(function () {
          return ngModel.$modelValue;
        }, function (newValue) {
          // Если указаны изображения (форма редактирования)
          if (newValue.length) {
            scope.uploaded = true;
            scope.images = ngModel.$viewValue;
          }

          ngModel.$render();
        });

        var input = element.find('input');
        var opts = {
          max_filesize: 2 * 1024 * 1024,
          types: ['image/png', 'image/jpg', 'image/jpeg']
        };

        ////////////////

        input.on('change', function (changeEvent) {
          var files = [];

          angular.forEach(changeEvent.target.files, function (file) {
            files.push(file);
          });

          var validator = validate(files);

          if (validator.status) {
            $q.all([uploadBinary(files)]).then(function (binaries) {
              scope.previewImages = binaries[0];
              scope.uploaded = true;

              ngModel.$setViewValue(files);
              ngModel.$setValidity('arrayRequired', true);
            });
          } else {
            printError(validator);
          }
        });

        function uploadBinary(files) {
          var deferred = $q.defer();
          var countUploaded = 0;
          var result = [];

          for (var i = 0; i < files.length; i++) {
            var dataURL = new FileReader();

            dataURL.onload = function (readerEvt) {
              countUploaded++;

              result.push(btoa(readerEvt.target.result));

              if (countUploaded === files.length) {
                deferred.resolve(result);
              }
            };

            dataURL.readAsBinaryString(files[i]);
          }

          return deferred.promise;
        }

        function fullPath(path) {
          return ENV.apiUrl + path;
        }

        function removeImage(image) {
          scope.images.splice(scope.images.indexOf(image), 1);
          images.remove([image.link]);

          if (!scope.images.length) {
            scope.uploaded = false;
            ngModel.$setValidity('arrayRequired', false);
          }

          ngModel.$setViewValue(scope.images);
        }

        function removePreview(image) {
          scope.previewImages.splice(scope.previewImages.indexOf(image), 1);

          if (!scope.previewImages.length) {
            scope.uploaded = false;
            ngModel.$setValidity('arrayRequired', false);
          }
        }

        function validate(files) {
          var valid = {
            status: true,
            reason: null
          };

          for (var i = 0; i < files.length; i++) {
            if (files[i].size > opts.max_filesize) {
              valid.status = false;
              valid.reason = 'max_filesize';
            }

            if (opts.types.indexOf(files[i].type) === -1) {
              valid.status = false;
              valid.reason = 'format';
            }
          }

          return valid;
        }

        function printError(validate) {
          var errorMsg = '';

          switch (validate.reason) {
            case 'max_filesize':
              errorMsg = 'Максимальний розмір файла 2Мб';
              break;
            case 'format':
              errorMsg = 'Заборонений тип файлу';
              break;
          }

          toastr.error(errorMsg);
        }
      }
    };
  }
})();
'use strict';

(function () {
    'use strict';

    angular.module('blocks.logger').factory('logger', logger);

    logger.$inject = ['$log', 'toastr'];

    function logger($log, toastr) {
        var service = {
            showToasts: true,

            error: error,
            info: info,
            success: success,
            warning: warning,

            // straight to console; bypass toastr
            log: $log.log
        };

        return service;
        /////////////////////

        function error(message, data, title) {
            toastr.error(message, title);
            $log.error('Error: ' + message, data);
        }

        function info(message, data, title) {
            toastr.info(message, title);
            $log.info('Info: ' + message, data);
        }

        function success(message, data, title) {
            toastr.success(message, title);
            $log.info('Success: ' + message, data);
        }

        function warning(message, data, title) {
            toastr.warning(message, title);
            $log.warn('Warning: ' + message, data);
        }
    }
})();
'use strict';

(function () {
  angular.module('blocks.dish-switch').directive('dishSwitch', dishSwitch);

  dishSwitch.$inject = ['dishes', 'toastr'];

  function dishSwitch(dishes, toastr) {
    return {
      restrict: 'E',
      replace: true,
      scope: {},
      require: 'ngModel',
      templateUrl: 'html/blocks/dish-switch/dish-switch.html',
      link: function link(scope, element, attr, ngModel) {
        scope.knobLabel = ' ';

        element.on('click', function () {
          scope.$apply(function () {
            scope.dish.enabled = !scope.dish.enabled;
            ngModel.$setViewValue(scope.dish);
            ngModel.$render();

            if (scope.dish.enabled === true) {
              dishes.activate({
                id: scope.dish.id
              });
            } else {
              dishes.deactivate({
                id: scope.dish.id
              });
            }
          });
        });

        ngModel.$render = function () {
          scope.dish = ngModel.$viewValue;
        };

        ngModel.$render();
      }
    };
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('blocks.edit-field', []).directive('editField', editField);

  editField.$inject = ['toastr', '$timeout'];

  function editField(toastr, $timeout) {
    return {
      restrict: 'E',
      replace: true,
      transclude: true,
      scope: {
        placeholder: '@',
        required: '@',
        mask: '@'
      },
      require: 'ngModel',
      templateUrl: 'html/blocks/edit-field/edit-field.html',
      link: function link(scope, element, attrs, ngModel) {
        scope.editMode = false;

        scope.editModeOn = function () {
          var input = void 0;
          var query = void 0;

          if (scope.mask) {
            query = element[0].getElementsByClassName('edit-field-input-mask');
          } else {
            query = element[0].getElementsByClassName('edit-field-input');
          }

          $timeout(function () {
            input = angular.element(query);
            input[0].focus();
          }, 100);

          scope.fieldData = ngModel.$viewValue;
          scope.editMode = true;
        };

        scope.editModeOff = function () {
          scope.fieldData = ngModel.$viewValue;
          scope.editMode = false;
        };

        scope.editSave = function () {
          if (!scope.fieldData && scope.required) {
            toastr.error('Поле не повинно бути порожнім!');
          } else {
            ngModel.$setViewValue(scope.fieldData);
            ngModel.$render();
            scope.editModeOff();
          }
        };

        var queryResult = element[0].getElementsByClassName('field-data-value');
        var spanElements = angular.element(queryResult);

        spanElements.bind('click', function () {
          scope.$apply(function () {
            scope.editModeOn();
          });

          event.preventDefault();
        });

        element.bind('keydown keypress', function (event) {
          if (event.which === 13) {
            scope.$apply(function () {
              scope.editSave();
            });

            event.preventDefault();
          }
        });

        ngModel.$render = function () {
          scope.fieldData = ngModel.$viewValue;
        };

        ngModel.$render();
      }
    };
  }
})();
'use strict';

(function () {
  angular.module('blocks.splash').directive('splashScreen', splashScreen).factory('splash', splash);

  splash.$inject = ['common', '$rootScope'];

  function splash(common, $rootScope) {
    var service = {
      show: showScreen,
      hide: hideScreen,
      delay: delayScreen
    };

    return service;

    /**
     * Запускает splash во время выполнения промисов
     * @param {Array} promise
     */

    function showScreen(promise) {
      $rootScope.splashScreen = true;

      common.$q.all(promise).then(function () {
        common.$timeout(function () {
          $rootScope.splashScreen = false;
        }, 600);
      });
    }

    function hideScreen() {
      common.$timeout(function () {
        $rootScope.splashScreen = false;
      }, 600);
    }

    function delayScreen(delay) {
      $rootScope.splashScreen = true;

      common.$timeout(function () {
        $rootScope.splashScreen = false;
      }, delay);
    }
  }

  function splashScreen() {
    return {
      restrict: 'E',
      replace: true,
      templateUrl: 'html/blocks/splash-screen/splash-screen.html'
    };
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('blocks.router').provider('routehelperConfig', routehelperConfig).factory('routehelper', routehelper);

  routehelper.$inject = ['$location', '$rootScope', '$route', 'logger', 'routehelperConfig'];

  // Must configure via the routehelperConfigProvider
  function routehelperConfig() {
    /* jshint validthis:true */
    this.config = {};

    this.$get = function () {
      return {
        config: this.config
      };
    };
  }

  function routehelper($location, $rootScope, $route, logger, routehelperConfig) {
    var handlingRouteChangeError = false;

    var routeCounts = {
      errors: 0
    };

    var routes = [];
    var $routeProvider = routehelperConfig.config.$routeProvider;

    var service = {
      configureRoutes: configureRoutes,
      getRoutes: getRoutes,
      routeCounts: routeCounts
    };

    init();

    return service;
    ///////////////

    function configureRoutes(routes) {
      routes.forEach(function (route) {
        route.config.resolve = angular.extend(route.config.resolve || {}, routehelperConfig.config.resolveAlways);
        $routeProvider.when(route.url, route.config);
      });

      $routeProvider.otherwise({ redirectTo: '/auth' });
    }

    function handleRoutingErrors() {
      // Route cancellation:
      // On routing error, go to the dashboard.
      // Provide an exit clause if it tries to do it twice.
      $rootScope.$on('$routeChangeError', function (event, current, previous, rejection) {
        if (handlingRouteChangeError) {
          return;
        }
        routeCounts.errors++;
        handlingRouteChangeError = true;
        var destination = current && (current.title || current.name || current.loadedTemplateUrl) || 'unknown target';
        var msg = 'Error routing to ' + destination + '. ' + (rejection.msg || '');
        logger.warning(msg, [current]);
        $location.path('/');
      });
    }

    function init() {
      handleRoutingErrors();
    }

    function getRoutes() {
      for (var prop in $route.routes) {
        if ($route.routes.hasOwnProperty(prop)) {
          var route = $route.routes[prop];
          var isRoute = !!route.title;
          if (isRoute) {
            routes.push(route);
          }
        }
      }

      return routes;
    }
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('blocks.refresh-btn').directive('refreshBtn', refreshBtn);

  refreshBtn.$inject = ['APP_EVENTS', '$rootScope', '$timeout'];

  function refreshBtn(APP_EVENTS, $rootScope, $timeout) {
    return {
      restrict: 'E',
      replace: true,
      scope: {},
      templateUrl: 'html/blocks/refresh-btn/refresh-btn.html',
      link: function link(scope) {
        scope.refreshPage = immediatelyRefresh;
        scope.refreshEnabled = false;

        var timeout = void 0;

        function immediatelyRefresh() {
          if (!scope.refreshEnabled) {
            $timeout.cancel(timeout);
            refreshPage();
          }
        }

        /**
         * Кидает событие по всему приложению,
         * событие перехватывают страницы на которых требуется
         * обновление, типо real time, 2007 год.
         */

        function refreshPage() {
          $rootScope.$broadcast(APP_EVENTS.refreshPage);
          scope.refreshEnabled = true;
        }

        function startTimeout() {
          timeout = $timeout(refreshPage, 20000);
        }

        // start
        startTimeout();

        var refreshListen = $rootScope.$on(APP_EVENTS.refreshPageDone, function () {
          scope.refreshEnabled = false;
          startTimeout();
        });

        scope.$on('$destroy', function () {
          if (timeout) {
            $timeout.cancel(timeout);
          }
        });

        scope.$on('$destroy', refreshListen);
      }
    };
  }
})();
'use strict';

(function () {
  angular.module('blocks.validator').directive('arrayRequired', arrayRequired);

  arrayRequired.$inject = [];

  function arrayRequired() {
    return {
      restrict: 'A',
      require: 'ngModel',
      link: function link(scope, elm, attrs, ngModel) {

        ngModel.$render = function () {
          if (ngModel.$viewValue.length) {
            ngModel.$setValidity('arrayRequired', true);
          } else {
            ngModel.$setValidity('arrayRequired', false);
          }
        };

        ngModel.$render();
      }
    };
  }
})();
'use strict';

(function () {
  angular.module('blocks.validator').factory('validator', validator);

  validator.$inject = [];

  function validator() {
    var validators = {
      required: required,
      phone: phone
    };

    var service = {
      run: runValidator
    };

    return service;

    ////////////////

    function runValidator(object, rules) {
      var report = {
        errors: []
      };

      rules.forEach(function (ruleObj) {
        if (object.hasOwnProperty(ruleObj.field)) {
          (function () {
            var value = object[ruleObj.field];

            ruleObj.rules.forEach(function (rule) {
              if (!validators[rule](value)) {
                report.errors.push({
                  field: ruleObj.field,
                  rule: rule
                });
              }
            });
          })();
        }
      });

      return report;
    }

    function required(field) {
      var result = false;

      if (Array.isArray(field)) {
        if (field.length) {
          result = true;
        }
      } else {
        if (field) {
          result = true;
        }
      }

      return result;
    }

    function phone(field) {
      var result = false;

      if (field.length === 10) {
        result = true;
      }

      return result;
    }
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.modals').factory('managerOrderDetailMiniModal', orderDetail).controller('managerOrderDetailMiniCtrl', orderDetailCtrl);

  orderDetail.$inject = ['ngDialog', 'BaseModal'];

  /* @ngInject */
  function orderDetail(ngDialog, BaseModal) {
    // Events that emit controller
    var events = {
      decline: 'decline'
    };

    var modal = new BaseModal('managerOrderDetailMiniModal', events);
    var service = angular.extend(modal, {
      show: showModal,
      hide: hideModal
    });

    return service;

    ////////////////

    function showModal() {
      ngDialog.open({
        template: 'html/modals/manager/order-detail-mini.html',
        showClose: false,
        appendClassName: BaseModal.getClassName() + ' order-detail',
        controller: 'managerOrderDetailMiniCtrl',
        controllerAs: 'vm'
      });
    }

    function hideModal() {
      ngDialog.close();
    }
  }

  orderDetailCtrl.$inject = ['BaseModal', 'helpers', 'toastr', '$scope', 'orders'];

  function orderDetailCtrl(BaseModal, helpers, toastr, $scope, orders) {
    var vm = this;
    var modal = BaseModal.get('managerOrderDetailMiniModal');

    vm.closeMessage = '';
    vm.showCloseMessage = vm.closeMessage ? true : false;
    vm.closeBtnMessage = vm.closeMessage ? 'відмінити' : 'відміна замовлення';

    vm.showCloseOrderForm = showCloseOrderForm;
    vm.hideCloseOrderForm = hideCloseOrderForm;

    activate();

    ////////////////

    function activate() {
      vm.spinner = true;
      vm.order = modal.scope.order;

      orders.getDishes({
        id: vm.order.id
      }, function (dishes) {
        vm.order.dishes = dishes;
        vm.orderInfo = helpers.calculateOrderInfo(vm.order);

        setTimeout(function () {
          $scope.$apply(function () {
            vm.spinner = false;
          });
        }, 500);
      });
    }

    /**
     * Показ формы отмены заказа
     */

    function showCloseOrderForm() {
      if (vm.showCloseMessage == true) {
        if (vm.closeMessage !== '') {
          var data = {
            id: vm.order.id,
            message: vm.closeMessage,
            closed: true,
            status: 'DELIVERY_FAILED'
          };

          orders.decline(data, function () {
            toastr.success('Замовлення закрите');
          });

          modal.emit(modal.events.decline, vm.order);
          modal.hide();
        } else {
          toastr.error('Введіть причину відмови від замовлення');
        }
      }

      vm.showCloseMessage = true;
      vm.closeBtnMessage = 'відмінити';
    }

    function hideCloseOrderForm() {
      vm.showCloseMessage = false;
      vm.closeBtnMessage = 'відміна замовлення';
    }
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.modals').factory('managerOrderDetailModal', orderDetail).controller('managerOrderDetailCtrl', orderDetailCtrl);

  orderDetail.$inject = ['ngDialog', 'BaseModal'];

  /* @ngInject */
  function orderDetail(ngDialog, BaseModal) {
    // Events that emit controller
    var events = {
      update: 'update',
      create: 'create',
      decline: 'decline'
    };

    var modal = new BaseModal('managerOrderDetailModal', events);
    var service = angular.extend(modal, {
      show: showModal,
      hide: hideModal
    });

    return service;

    ////////////////

    function showModal() {
      ngDialog.open({
        template: 'html/modals/manager/order-detail.html',
        showClose: false,
        appendClassName: BaseModal.getClassName() + ' order-detail',
        controller: 'managerOrderDetailCtrl',
        controllerAs: 'vm'
      });
    }

    function hideModal() {
      ngDialog.close();
    }
  }

  orderDetailCtrl.$inject = ['BaseModal', 'dishesSelectModal', 'orderHistoryModal', 'admin', 'operator', 'helpers', 'validator', 'toastr', '$scope', 'orders'];

  function orderDetailCtrl(BaseModal, selectModal, historylModal, admin, operator, helpers, validator, toastr, $scope, orders) {
    var vm = this;
    var modal = BaseModal.get('managerOrderDetailModal');
    var clientRules = [{
      field: 'name',
      rules: ['required']
    }, {
      field: 'address',
      rules: ['required']
    }, {
      field: 'phoneNumber',
      rules: ['required', 'phone']
    }];

    var orderRules = [{
      field: 'dishes',
      rules: ['required']
    }];

    // Модалка работает в двух "режимах", создание нового заказа - пустая
    // и редактирование существующего заказа
    vm.createEnabled = modal.scope.createEnabled;

    if (vm.createEnabled) {
      var orderFrame = {
        client: {
          address: '',
          name: '',
          phoneNumber: ''
        },
        dishes: [],
        status: 'FRESH'
      };

      vm.order = orderFrame;
    } else {
      vm.spinner = true;
      vm.order = modal.scope.order;

      orders.getDishes({
        id: vm.order.id
      }, function (dishes) {
        vm.order.dishes = transformDishes(dishes);

        setTimeout(function () {
          $scope.$apply(function () {
            vm.spinner = false;
          });
        }, 500);
      });
    }

    vm.closeMessage = '';
    vm.showCloseMessage = vm.closeMessage ? true : false;
    vm.closeBtnMessage = vm.closeMessage ? 'відмінити' : 'відміна замовлення';
    vm.orderValid = true;

    // добаление новых дишов, показ истории заказов клиента
    vm.selectDishesModal = showSelectModal;
    vm.historyOrdersModal = showHistoryModal;
    // ред заказа
    vm.incQuantity = incQuantity;
    vm.decQuantity = decQuantity;
    vm.removeDish = removeDish;
    // доп. модалки
    vm.showCloseOrderForm = showCloseOrderForm;
    vm.hideCloseOrderForm = hideCloseOrderForm;
    // сохранение изменений (передача заказа на кухню)
    vm.saveOrder = saveOrder;
    vm.convertHHmm = convertHHmm;
    vm.makeCall = makeCall;

    ////////////////

    /**
     * Увеличение кол-во блюда
     * @param {Object} dish
     */

    function incQuantity(dish) {
      var search = helpers.searchByKey(vm.order.dishes, { dishId: dish.dishId });
      search.quantity++;
    }

    /**
     * Уменьшение кол-во блюда
     * @param {Object} dish
     */

    function decQuantity(dish) {
      var search = helpers.searchByKey(vm.order.dishes, { dishId: dish.dishId });
      search.quantity--;

      if (!search.quantity) {
        if (!lastDishInOrder()) {
          // Удаляем блюдо из списка
          vm.order.dishes.splice(vm.order.dishes.indexOf(search), 1);
        } else {
          search.quantity++;
        }
      }
    }

    /**
     * Удаление блюда из списка
     * @param {Object} dish
     */

    function removeDish(dish) {
      if (!lastDishInOrder()) {
        var search = helpers.searchByKey(vm.order.dishes, { dishId: dish.dishId });
        vm.order.dishes.splice(vm.order.dishes.indexOf(search), 1);
      }
    }

    // Блокировка удаление последнего блюда из состава заказа
    function lastDishInOrder() {
      if (!(vm.order.dishes.length - 1)) {
        toastr.error('Замовлення не можу бути порожнім!');
        return true;
      }

      return false;
    }

    /**
     * Показ модального окна с ред. заказа
     */

    function showSelectModal() {
      // что бы избавиться от two data binding
      var copy = angular.copy(vm.order);

      selectModal.scope.dishes = copy.dishes;
      selectModal.show();
    }

    /**
     * Показ модального окна с историей заказов
     */

    function showHistoryModal() {
      admin.history({
        clientPhone: vm.order.client.phoneNumber
      }, function (result) {
        historylModal.scope = {
          orders: result,
          hideBack: true
        };

        historylModal.show();
      });
    }

    /**
     * Показ формы отмены заказа
     */

    function showCloseOrderForm() {
      if (vm.showCloseMessage == true) {
        if (vm.closeMessage !== '') {
          var data = {
            id: vm.order.id,
            message: vm.closeMessage,
            closed: true,
            status: 'DECLINED'
          };

          // (Call центр) отменяем на этапе уточнения заказа
          orders.decline(data, function () {
            toastr.success('Замовлення відмінено');
          });

          modal.emit(modal.events.decline, vm.order);
          modal.hide();
        } else {
          toastr.error('Введіть причину відмови від замовлення');
        }
      }

      vm.showCloseMessage = true;
      vm.closeBtnMessage = 'відмінити';
    }

    function hideCloseOrderForm() {
      vm.showCloseMessage = false;
      vm.closeBtnMessage = 'відміна замовлення';
    }

    /**
     * Сохранение заказа либо обновление либо создание нового
     */

    function saveOrder() {
      if (vm.order.dishes.length) {
        if (vm.createEnabled) {
          createOrder();
        } else {
          updateOrder();
        }
      } else {
        toastr.error('Замовлення не можу бути порожнім!');
      }
    }

    function createOrder() {
      vm.order.status = 'KITCHEN';

      var timeToDeliver = null;

      if (vm.order.timeToDeliver) {
        var today = helpers.getDate();
        var hhmm = convertHHmm(vm.order.timeToDeliver);
        timeToDeliver = today.str + ' ' + hhmm + ':00';
      }

      // Подготовака данных для отправки
      var orderData = {
        id: vm.order.id,
        client: {
          name: vm.order.client.name,
          phone: vm.order.client.phoneNumber,
          address: vm.order.client.address
        },
        dishes: vm.order.dishes,
        timeToDeliver: timeToDeliver,
        status: vm.order.status
      };

      modal.hide();

      orders.create(orderData, function (order) {
        modal.emit(modal.events.create, order);
        toastr.success('Замовлення оформлено');
      });
    }

    function updateOrder() {
      vm.order.status = 'KITCHEN';

      var timeToDeliver = null;

      if (vm.order.timeToDeliver) {
        var today = helpers.getDate();
        var hhmm = convertHHmm(vm.order.timeToDeliver);
        timeToDeliver = today.str + ' ' + hhmm + ':00';
      }

      // Подготовака данных для отправки
      var orderData = {
        id: vm.order.id,
        client: {
          name: vm.order.client.name,
          phone: vm.order.client.phoneNumber,
          address: vm.order.client.address
        },
        dishes: vm.order.dishes,
        timeToDeliver: timeToDeliver,
        status: vm.order.status
      };

      modal.emit(modal.events.update, vm.order);
      modal.hide();

      orders.update(orderData, function () {
        toastr.success('Замовлення оформлено');
      });
    }

    /**
     * Простая проверка на заполнение полей заказа
     * @param {Object }order
     * @returns {boolean}
     */

    function validateOrder(order) {
      var result = false;

      var clientReport = validator.run(order.client, clientRules);
      var orderReport = validator.run(order, orderRules);

      if (!clientReport.errors.length && !orderReport.errors.length) {
        result = true;
      }

      return result;
    }

    /**
     * Представление строки вида 2359 в 23:59
     * @param str
     * @returns {string}
     */

    function convertHHmm(str) {
      if (str) {
        var foo = helpers.getHourMinutes(str);
        if (foo) {
          return foo.hours + ':' + foo.minutes;
        }
      }
    }

    /**
     * Трансформирование данных о заказе от сервера в более удобный вид
     */

    function transformDishes(dishes) {
      console.log(dishes);
      return dishes.map(function (dish) {
        return {
          dish: dish.dish,
          id: dish.id,
          dishId: dish.dish.id,
          quantity: dish.quantity
        };
      });
    }

    /**
     * Совершение звонка на телефон указанный в заказе
     */

    function makeCall() {
      operator.makeCall({
        line: '901',
        phone: vm.order.client.phoneNumber
      });
    }

    /**
     * Обновление orderInfo
     */

    $scope.$watch(function () {
      return vm.order.dishes;
    }, function (newValue) {
      if (newValue) {
        vm.orderInfo = helpers.calculateOrderInfo(vm.order);
      }
    }, true);

    /**
     * Валидация заказа
     */

    $scope.$watch(function () {
      return vm.order;
    }, function (newValue) {
      if (validateOrder(newValue)) {
        vm.orderValid = true;
      } else {
        vm.orderValid = false;
      }
    }, true);

    /**
     * Выбранны новые блюда
     */

    selectModal.on(selectModal.events.selected, function (dishes) {
      vm.order.dishes = dishes;
    });
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.modals').factory('orderHistoryModal', orderHistory).controller('orderHistoryModalCtrl', orderHistoryCtrl);

  orderHistory.$inject = ['ngDialog', 'BaseModal'];

  /* @ngInject */
  function orderHistory(ngDialog, BaseModal) {

    var modal = new BaseModal('orderHistoryModal');
    var service = angular.extend(modal, {
      show: showModal,
      hide: hideModal
    });

    return service;

    ////////////////

    function showModal() {
      ngDialog.open({
        template: 'html/modals/history/history.html',
        showClose: false,
        appendClassName: BaseModal.getClassName() + ' orders-history',
        controller: 'orderHistoryModalCtrl',
        controllerAs: 'vm'
      });
    }

    function hideModal() {
      ngDialog.close();
    }
  }

  orderHistoryCtrl.$inject = ['BaseModal', 'orderHistoryIntervalModal'];

  function orderHistoryCtrl(BaseModal, intervalModal) {
    var vm = this;
    var modal = BaseModal.get('orderHistoryModal');

    vm.orders = addShowDetailProperty(modal.scope.orders);
    vm.hideBack = modal.scope.hideBack;
    vm.showIntervalModal = showIntervalModal;
    vm.toggleOrderDetail = toggleOrderDetail;

    ////////////////

    function showIntervalModal() {
      modal.hide();
      intervalModal.show();
    }

    function addShowDetailProperty(orders) {
      return orders.map(function (order) {
        return angular.extend(order, {
          showDetail: false
        });
      });
    }

    function toggleOrderDetail(order) {
      order.showDetail = !order.showDetail;
    }
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.modals').factory('orderHistoryIntervalModal', orderHistoryInterval).controller('orderHistoryIntervalModalCtrl', orderHistoryIntervalCtrl);

  orderHistoryInterval.$inject = ['ngDialog', 'BaseModal'];

  /* @ngInject */
  function orderHistoryInterval(ngDialog, BaseModal) {

    var modal = new BaseModal('orderHistoryIntervalModal');
    var service = angular.extend(modal, {
      show: showModal,
      hide: hideModal
    });

    return service;

    ////////////////

    function showModal() {
      ngDialog.open({
        template: 'html/modals/history/interval.html',
        width: '30%',
        showClose: false,
        appendClassName: BaseModal.getClassName(),
        controller: 'orderHistoryIntervalModalCtrl',
        controllerAs: 'vm'
      });
    }

    function hideModal() {
      ngDialog.close();
    }
  }

  orderHistoryIntervalCtrl.$inject = ['admin', 'orderHistoryModal', 'BaseModal'];

  function orderHistoryIntervalCtrl(admin, historyModal, BaseModal) {
    var vm = this;
    var modal = BaseModal.get('orderHistoryIntervalModal');

    vm.spinner = false;
    vm.getOrders = getOrders;
    vm.form = {
      start: '',
      finish: ''
    };

    ////////////////

    function getOrders() {
      vm.spinner = true;

      var sendData = {
        startDate: vm.form.start + ' 00:00:00',
        endDate: vm.form.finish + ' 00:00:00'
      };

      admin.history(sendData, function (result) {
        vm.spinner = false;
        historyModal.scope = {
          orders: result
        };

        modal.hide();
        historyModal.show();
      });
    }
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.modals').factory('dishesCreateModal', createDish).controller('dishesCreateModalCtrl', createDishCtrl);

  createDish.$inject = ['ngDialog', 'BaseModal'];

  /* @ngInject */
  function createDish(ngDialog, BaseModal) {
    // Events that emit controller
    var events = {
      create: 'create'
    };

    var modal = new BaseModal('dishesCreateModal', events);
    var service = angular.extend(modal, {
      show: showModal,
      hide: hideModal
    });

    return service;

    ////////////////

    function showModal() {
      ngDialog.open({
        template: 'html/modals/dishes/create.html',
        width: '60%',
        showClose: false,
        controller: 'dishesCreateModalCtrl',
        controllerAs: 'vm'
      });
    }

    function hideModal() {
      ngDialog.close();
    }
  }

  createDishCtrl.$inject = ['dishes', 'images', 'BaseModal', 'toastr'];

  function createDishCtrl(dishes, images, BaseModal, toastr) {
    var vm = this;
    var modal = BaseModal.get('dishesCreateModal');

    vm.create = createDish;
    vm.spinner = false;
    vm.form = {
      images: [],
      name: '',
      price: '',
      description: '',
      type: 'ORDINARY',
      categoryId: modal.scope.selectedCategory.id
    };

    vm.types = [{
      name: 'Звичайний',
      value: 'ORDINARY'
    }, {
      name: 'Новинка',
      value: 'LATEST'
    }, {
      name: 'Гостра страва',
      value: 'HOT'
    }, {
      name: 'Вегетаріанська страва',
      value: 'VEGAN'
    }];

    ////////////////

    function createDish() {
      vm.spinner = true;

      dishes.create(vm.form, function (created) {
        var fd = new FormData();
        fd.append('id', created.id);
        fd.append('type', 'dish');

        vm.form.images.forEach(function (image) {
          fd.append('images[]', image);
        });

        images.upload(fd, function () {
          vm.spinner = false;

          modal.hide();
          toastr.success('Страву додано');

          modal.emit(modal.events.create);
        });
      }, function () {
        vm.spinner = false;
      });
    }
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.modals').factory('dishesEditModal', editDish).controller('dishesEditModalCtrl', dishesEditModalCtrl);

  editDish.$inject = ['ngDialog', 'BaseModal'];

  /* @ngInject */
  function editDish(ngDialog, BaseModal) {
    // Events that emit controller
    var events = {
      update: 'update'
    };

    var modal = new BaseModal('dishesEditModal', events);
    var service = angular.extend(modal, {
      show: showModal,
      hide: hideModal
    });

    return service;

    ////////////////

    function showModal() {
      ngDialog.open({
        template: 'html/modals/dishes/edit.html',
        width: '60%',
        showClose: false,
        controller: 'dishesEditModalCtrl',
        controllerAs: 'vm'
      });
    }

    function hideModal() {
      ngDialog.close();
    }
  }

  dishesEditModalCtrl.$inject = ['dishes', 'images', 'BaseModal', 'toastr'];

  function dishesEditModalCtrl(dishes, images, BaseModal, toastr) {
    var vm = this;
    var modal = BaseModal.get('dishesEditModal');

    vm.update = updateDish;
    vm.spinner = false;
    vm.form = {
      images: modal.scope.images,
      id: modal.scope.id,
      name: modal.scope.name,
      price: modal.scope.price,
      description: modal.scope.description,
      type: modal.scope.type,
      categoryId: modal.scope.categoryId
    };

    vm.types = [{
      name: 'Звичайний',
      value: 'ORDINARY'
    }, {
      name: 'Новинка',
      value: 'LATEST'
    }, {
      name: 'Гостра страва',
      value: 'HOT'
    }, {
      name: 'Вегетаріанська страва',
      value: 'VEGAN'
    }];

    ////////////////

    function updateDish() {
      vm.spinner = true;

      // Если загружаются новые изображения
      if (checkNewImages()) {
        dishes.update(vm.form, function (updateDish) {
          var fd = new FormData();
          fd.append('id', vm.form.id);
          fd.append('type', 'dish');

          vm.form.images.forEach(function (image) {
            fd.append('images[]', image);
          });

          images.upload(fd, function () {
            vm.spinner = false;

            modal.hide();
            toastr.success('Страву обновлено');

            modal.emit(modal.events.update, updateDish);
          });
        }, function () {
          vm.spinner = false;
        });
      } else {
        dishes.update(vm.form, function (updateDish) {
          vm.spinner = false;

          modal.hide();
          toastr.success('Страву обновлено');

          modal.emit(modal.events.update, updateDish);
        }, function () {
          vm.spinner = false;
        });
      }
    }

    function checkNewImages() {
      var isset = false;

      vm.form.images.forEach(function (image) {
        if (image.type) {
          isset = true;
        }
      });

      return isset;
    }
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.modals').factory('dishesSelectModal', selectDish).controller('dishesSelectModalCtrl', selectDishCtrl);

  selectDish.$inject = ['ngDialog', 'BaseModal'];

  /* @ngInject */
  function selectDish(ngDialog, BaseModal) {
    // Events that emit controller
    var events = {
      selected: 'selected'
    };

    var modal = new BaseModal('dishesSelectModal', events);
    var service = angular.extend(modal, {
      show: showModal,
      hide: hideModal
    });

    return service;

    ////////////////

    function showModal() {
      ngDialog.open({
        template: 'html/modals/dishes/select.html',
        showClose: false,
        appendClassName: BaseModal.getClassName() + ' select-modal',
        controller: 'dishesSelectModalCtrl',
        controllerAs: 'vm'
      });
    }

    function hideModal() {
      // TODO грязный хак, dishesSelectModal вызывается поверх другого
      // модального окна
      var dialogs = ngDialog.getOpenDialogs();
      ngDialog.close(dialogs[1]);
    }
  }

  selectDishCtrl.$inject = ['$timeout', 'categories', 'helpers', '$q', 'BaseModal'];

  function selectDishCtrl($timeout, categories, helpers, $q, BaseModal) {
    var vm = this;
    var modal = BaseModal.get('dishesSelectModal');

    vm.spinner = true;
    vm.searchDish = searchDish;
    vm.loadDishes = loadDishes;
    vm.incQuantity = incQuantity;
    vm.decQuantity = decQuantity;
    vm.pushDishes = pushDishes;

    vm.listOfDishes = modal.scope.dishes;
    vm.categories = [];
    vm.dishes = [];
    vm.selectedCategory;

    $q.all([activate()]).then(function () {
      hideSpinner();
    });

    ////////////////

    function activate() {
      return categories.fetchAll().$promise.then(function (categories) {
        vm.categories = categories;
        return categories[0];
      }).then(function (firstCategory) {
        return categories.fetchDishes({
          id: firstCategory.id
        }).$promise.then(function (dishes) {
          vm.selectedCategory = firstCategory;
          vm.dishes = transformDishesData(dishes);
        });
      });
    }

    function loadDishes(category) {
      vm.spinner = true;

      categories.fetchDishes({
        id: category.id
      }, function (dishes) {
        vm.selectedCategory = category;
        vm.dishes = transformDishesData(dishes);

        hideSpinner();
      });
    }

    /**
     * Увеличение кол-во блюда
     * @param {Object} dish
     */

    function incQuantity(dish) {
      // Пытаемся найти переданное блюдо в списке
      var search = searchDish(dish);

      if (search) {
        search.quantity++;
      } else {
        dish.quantity = 1;

        vm.listOfDishes.push(dish);
      }
    }

    /**
     * Уменьшение кол-во блюда
     * @param {Object} dish
     */

    function decQuantity(dish) {
      var search = searchDish(dish);

      if (search) {
        search.quantity--;

        if (!search.quantity) {
          vm.listOfDishes.splice(vm.listOfDishes.indexOf(search), 1);
        }
      }
    }

    function searchDish(dish) {
      return helpers.searchByKey(vm.listOfDishes, { dishId: dish.dishId });
    }

    /**
     * Отправляем список из выбранных блюд
     */

    function pushDishes() {
      modal.emit(modal.events.selected, vm.listOfDishes);
      modal.hide();
    }

    /**
     * Трансформирование данных о блюдах от сервера в более удобный вид
     */

    function transformDishesData(dishes) {
      return dishes.map(function (dish) {
        return {
          dish: dish,
          dishId: dish.id,
          quantity: 0
        };
      });
    }

    function hideSpinner() {
      $timeout(function () {
        vm.spinner = false;
      }, 400);
    }
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.modals').factory('categoriesCreateModal', createCategory).controller('categoriesCreateModalCtrl', createCategoryCtrl);

  createCategory.$inject = ['ngDialog', 'BaseModal'];

  /* @ngInject */
  function createCategory(ngDialog, BaseModal) {
    // Events that emit controller
    var events = {
      create: 'create'
    };

    var modal = new BaseModal('createModal', events);
    var service = angular.extend(modal, {
      show: showModal,
      hide: hideModal
    });

    return service;

    ////////////////

    function showModal() {
      ngDialog.open({
        template: 'html/modals/categories/categories.html',
        width: '30%',
        showClose: false,
        controller: 'categoriesCreateModalCtrl',
        controllerAs: 'vm'
      });
    }

    function hideModal() {
      ngDialog.close();
    }
  }

  createCategoryCtrl.$inject = ['categories', 'BaseModal', 'toastr'];

  function createCategoryCtrl(categories, BaseModal, toastr) {
    var vm = this;
    var modal = BaseModal.get('createModal');

    vm.create = createCategory;
    vm.form = {
      name: ''
    };

    ////////////////

    function createCategory() {
      categories.create(vm.form, function () {
        modal.hide();
        toastr.success('Категорія добавлена');

        modal.emit(modal.events.create);
      });
    }
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.auth').controller('Auth', Auth);

  Auth.$inject = ['$rootScope', 'user', 'splash', 'logger'];

  function Auth($rootScope, user, splash, logger) {
    var vm = this;
    vm.form = {
      username: '',
      password: ''
    };

    vm.login = function () {
      user.login(vm.form).then(function () {
        var info = user.info();
        logger.success('Вхід здійснено успішно: ' + info.sub);
        splash.delay(1500);

        $rootScope.defaultRedirect();
      }).finally(function () {
        vm.form = {
          username: '',
          password: ''
        };
      });
    };
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.auth').run(appRun);

  /* @ngInject */
  function appRun(routehelper, USER_ROLES) {
    routehelper.configureRoutes(getRoutes(USER_ROLES));
  }

  /* @ngInject */
  function getRoutes(USER_ROLES) {
    return [{
      url: '/auth',
      config: {
        templateUrl: 'html/components/common/auth/auth.html',
        controller: 'Auth',
        controllerAs: 'auth',
        data: {
          authorities: [USER_ROLES.guest]
        }
      }
    }];
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.admin.dashboard').controller('DashboardAdmin', DashboardAdmin);

  DashboardAdmin.$inject = ['orders', 'APP_EVENTS', '$scope', '$q', 'admin', 'helpers', 'ngDialog'];

  /* @ngInject */
  function DashboardAdmin(orders, APP_EVENTS, $scope, $q, admin, helpers, ngDialog) {
    var vm = this;

    vm.callCenter = [];
    vm.kitchen = [];
    vm.delivery = [];
    vm.ordersLoading = true;
    vm.showModalOrder = showModalOrder;

    var selectedOrder = void 0;
    var deliveryModal = void 0;
    var statuses = {
      callCenter: ['FRESH', 'IN_PROGRESS'],
      kitchen: ['KITCHEN', 'COOKING', 'PREPARED'],
      delivery: ['DELIVERY', 'DONE']
    };

    activate();

    ////////////////

    function activate() {
      return orders.fetchAvailable({}).$promise.then(function (orders) {
        vm.callCenter = filterOrdersByStatus(orders, statuses.callCenter).sort(helpers.compareById);
        vm.kitchen = filterOrdersByStatus(orders, statuses.kitchen).sort(helpers.compareById);
        vm.delivery = filterOrdersByStatus(orders, statuses.delivery).sort(helpers.compareById);
        vm.ordersLoading = false;
      });
    }

    /**
     * Фильтрация всех заказов по переданным статусам
     * @param {Array} orders
     * @param {Array} statuses
     * @returns {Array}
     */

    function filterOrdersByStatus(orders, statuses) {
      var results = [];

      orders.forEach(function (order) {
        if (helpers.findString(statuses, order.status)) {
          results.push(order);
        }
      });

      return results;
    }

    /**
     * Модальное окно с детальной информацией о заказе
     * @param order
     */

    function showModalOrder(order) {
      selectedOrder = order;

      if (selectedOrder.timeToDeliver) {
        selectedOrder.timeToDeliver = helpers.parseDate(selectedOrder.timeToDeliver);
      }

      ngDialog.open({
        template: 'html/modals/order-detail-admin.html',
        className: 'ngdialog-theme-default order-detail',
        controller: orderDetailModalCtrl
      });
    }

    function calculateOrderInfo(order) {
      var result = {
        price: 0,
        count: 0
      };

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = order.dishes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var dish = _step.value;

          result.price += dish.dish.price * dish.quantity;
          result.count += dish.quantity;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return result;
    }

    /**
     * Переносит заказ из колонки Кухня в Доставку, а так же сортирует
     * @param {Object} order
     */

    function transferOrderInDelivery(order) {
      var search = helpers.searchByKey(vm.kitchen, { id: order.id });

      vm.kitchen.splice(vm.kitchen.indexOf(search), 1);
      vm.delivery.push(order);
      vm.delivery.sort(helpers.compareById);
    }

    /**
     * Обновление страницы
     */

    $scope.$on(APP_EVENTS.refreshPage, function () {
      $q.all([activate()]).then(function () {
        $scope.$emit(APP_EVENTS.refreshPageDone);
      });
    });

    orderDetailModalCtrl.$inject = ['$scope', 'helpers', 'toastr', 'orders', 'admin'];

    /**
     * Контроллер модального окна с деталями заказа
     */

    function orderDetailModalCtrl($scope, helpers, toastr, orders, admin) {

      $scope.spinner = true;
      $scope.closeMessage = '';
      $scope.showCloseMessage = $scope.closeMessage ? true : false;
      $scope.closeBtnMessage = $scope.closeMessage ? 'відмінити' : 'відміна замовлення';
      $scope.showModalDelivery = showModalDelivery;
      $scope.makeInCooking = makeInCooking;
      $scope.convertHHmm = convertHHmm;

      activate(selectedOrder);

      ////////////////

      function activate(order) {
        orders.getDishes({
          id: order.id
        }, function (dishes) {
          order.dishes = dishes;
          $scope.order = order;
          $scope.orderInfo = calculateOrderInfo(order);

          setTimeout(function () {
            $scope.$apply(function () {
              $scope.spinner = false;
            });
          }, 500);
        });
      }

      $scope.showCloseOrderForm = function () {
        if ($scope.showCloseMessage == true) {
          if ($scope.closeMessage !== '') {
            var data = {
              id: $scope.order.id,
              status: 'CANT_PREPARE',
              closed: true,
              message: $scope.closeMessage
            };

            orders.decline(data, function () {
              toastr.success('Замовлення відмінено');
            });

            var search = helpers.searchByKey(vm.kitchen, { id: selectedOrder.id });
            vm.kitchen.splice(vm.kitchen.indexOf(search), 1);
            vm.kitchen.sort(helpers.compareById);

            ngDialog.close();
          } else {
            toastr.error('Введіть причину відмови від замовлення');
          }
        }

        $scope.showCloseMessage = true;
        $scope.closeBtnMessage = 'відмінити';
      };

      $scope.hideCloseOrderForm = function () {
        $scope.showCloseMessage = false;
        $scope.closeBtnMessage = 'відміна замовлення';
      };

      /**
       * Кнопка выдано курьеру
       */

      $scope.passOrder = function () {
        if (selectedOrder.courier) {
          admin.passOrderToCourier({
            id: selectedOrder.id
          }, function () {
            toastr.success('Замовлення видано кур’єру');
          });

          selectedOrder.status = 'DELIVERY';
          transferOrderInDelivery(selectedOrder);
          ngDialog.close();
        } else {
          toastr.warning('Необхідно назначити кур’єра на замовлення!');
        }
      };

      /**
       * Модальное окно с назначением курьера на заказ
       * @param order
       */

      function showModalDelivery() {
        deliveryModal = ngDialog.open({
          template: 'html/modals/order-delivery-admin.html',
          width: '350px',
          showClose: false,
          controller: orderDeliveryModalCtrl
        });
      }

      function makeInCooking() {
        selectedOrder.status = 'COOKING';
        admin.makeInCooking({
          id: selectedOrder.id
        }, function () {
          toastr.success('Замовлення відправлено на кухню');
        });

        ngDialog.close();
      }

      /**
       * Представление строки вида 2359 в 23:59
       * @param str
       * @returns {string}
       */

      function convertHHmm(str) {
        if (str) {
          var foo = helpers.getHourMinutes(str);
          if (foo) {
            return foo.hours + ':' + foo.minutes;
          }
        }
      }
    }

    /**
     * Контроллер модального окна с выбором курьера
     */

    orderDeliveryModalCtrl.$inject = ['$scope', 'courier', 'toastr'];

    function orderDeliveryModalCtrl($scope, courier, toastr) {

      $scope.closeModal = closeModal;
      $scope.showForm = showForm;
      $scope.sendCourier = sendCourier;
      $scope.courierList = [];
      $scope.pageLoading = true;

      $scope.formCourier = {
        id: 0,
        start: '',
        finish: ''
      };

      activate();

      ////////////////

      function activate() {
        courier.fetchAll({}, function (couriers) {
          $scope.courierList = transformCouriers(couriers);
          $scope.pageLoading = false;
        });
      }

      function closeModal() {
        deliveryModal.close();
      }

      /**
       * Показывает форму для отправки курьера
       * @param courier
       */

      function showForm(courier) {
        if (courier.status === 'BUSY') {
          toastr.warning('Кур’єр зайнятий');
        } else {
          hideAllFormsExceptCourier(courier);

          $scope.formCourier.id = courier.id;
          courier.showForm = !courier.showForm;
        }
      }

      /**
       * Скрывает все формы у курьеров за исключением переданного курьера
       * @param courier
       */

      function hideAllFormsExceptCourier(courier) {
        $scope.courierList.forEach(function (cour) {
          if (cour.id !== courier.id) {
            cour.showForm = false;
          }
        });
      }

      function sendCourier(courier) {
        var today = helpers.getDate();

        if (validateForm()) {
          var todayStr = today.yyyy + '-' + today.mm + '-' + today.dd;
          var start = helpers.getHourMinutes($scope.formCourier.start);
          var finish = helpers.getHourMinutes($scope.formCourier.finish);

          orders.update({
            timeToTake: todayStr + ' ' + start.hours + ':' + start.minutes + ':00',
            timeToDeliver: todayStr + ' ' + finish.hours + ':' + finish.minutes + ':00',
            id: selectedOrder.id,
            courierId: courier.id
          });

          selectedOrder.courier = courier;
          toastr.success('Інформація передана кур’єру');

          closeModal();
        } else {
          toastr.error('Необхідно заповнити всі поля');
        }
      }

      /**
       * Проверка формы на заполнение всех полей
       * @returns {boolean}
       */

      function validateForm() {
        var result = true;

        for (var prop in $scope.formCourier) {
          if ($scope.formCourier.hasOwnProperty(prop)) {
            if (!$scope.formCourier[prop]) {
              result = false;
            }
          }
        }

        return result;
      }

      /**
       * Транформирование данных от сервера в более удобный вид
       * @param couriers
       * @returns {Array}
       */

      function transformCouriers(couriers) {
        var online = couriers.filter(function (courier) {
          if (courier.status !== 'OUT') {
            return true;
          }
        });

        return online.map(function (courier) {
          var free = courier.status === 'FREE' ? true : false;
          var statusText = free ? 'вільний' : 'зайнятий';

          return {
            account: courier.account,
            id: courier.id,
            messagingToken: courier.messagingToken,
            status: courier.status,
            statusText: statusText,
            free: free,
            showForm: false
          };
        });
      }
    }
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.admin.dashboard').run(appRun);

  /* @ngInject */
  function appRun(routehelper, USER_ROLES) {
    routehelper.configureRoutes(getRoutes(USER_ROLES));
  }

  /* @ngInject */
  function getRoutes(USER_ROLES) {
    return [{
      url: '/admin/dashboard',
      config: {
        templateUrl: 'html/components/admin/dashboard/dashboard.html',
        controller: 'DashboardAdmin',
        controllerAs: 'dash',
        data: {
          authorities: [USER_ROLES.admin]
        }
      }
    }];
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.admin.panel').controller('Panel', Panel);

  Panel.$inject = ['dishesCreateModal', 'dishesEditModal', 'categoriesCreateModal', 'helpers', 'categories', '$timeout', '$q', 'toastr'];

  function Panel(dishCreateModal, dishEditModal, categoryModal, helpers, categories, $timeout, $q, toastr) {
    var vm = this;

    dishCreateModal.scope = vm;

    vm.spinner = true;
    vm.loadDishes = loadDishes;
    vm.removeDish = removeDishFromCategory;
    vm.removeCategory = removeCategory;
    vm.showModalDishAdd = dishCreateModal.show;
    vm.showModalCategoryAdd = categoryModal.show;
    vm.showModalDishEdit = showDishEditModal;
    vm.selectedCategory;

    $q.all([activate()]).then(function () {
      hideSpinner();
    });

    ////////////

    function activate() {
      return categories.fetchAll().$promise.then(function (categories) {
        vm.categories = categories;

        return categories[0];
      }).then(function (firstCategory) {
        return categories.fetchDishes({
          id: firstCategory.id
        }).$promise.then(function (dishes) {
          vm.selectedCategory = firstCategory;
          vm.dishes = dishes;
        });
      });
    }

    function loadDishes(category) {
      vm.spinner = true;

      categories.fetchDishes({
        id: category.id
      }, function (dishes) {
        vm.selectedCategory = category;
        vm.dishes = dishes;

        hideSpinner();
      });
    }

    function removeCategory() {
      var msg = 'Ви справді бажаєте видалити категорію - ' + vm.selectedCategory.name + '?';

      if (confirm(msg)) {
        categories.remove({
          id: vm.selectedCategory.id
        }, function () {
          var search = helpers.searchByKey(vm.categories, {
            id: vm.selectedCategory.id
          });

          vm.categories.splice(vm.categories.indexOf(search), 1);
          vm.selectedCategory = vm.categories[0];
          loadDishes(vm.categories[0]);

          toastr.success('Категорія видалена');
        });
      }
    }

    function removeDishFromCategory(idDish) {
      var msg = 'Ви справді бажаєте видалити страву?';

      if (confirm(msg)) {
        categories.removeDish({
          id: vm.selectedCategory.id,
          dishes: [{
            id: idDish
          }]
        }, function () {
          var search = helpers.searchByKey(vm.dishes, {
            id: idDish
          });

          vm.dishes.splice(vm.dishes.indexOf(search), 1);
          toastr.success('Страву видалено');
        });
      }
    }

    function showDishEditModal(dish) {
      var data = angular.extend({
        categoryId: vm.selectedCategory.id
      }, dish);

      var copy = angular.copy(data);

      dishEditModal.scope = copy;
      dishEditModal.show();
    }

    function hideSpinner() {
      $timeout(function () {
        vm.spinner = false;
      }, 400);
    }

    /**
     * Добавление нового блюда в модальном окне
     */

    dishCreateModal.on(dishCreateModal.events.create, function () {
      // Reload list of dishes
      categories.fetchDishes({
        id: vm.selectedCategory.id
      }, function (dishes) {
        vm.dishes = dishes;
      });
    });

    /**
     * Изменение блюда в модальном окне
     */

    dishEditModal.on(dishEditModal.events.update, function (updateDish) {
      // Reload list of dishes
      categories.fetchDishes({
        id: vm.selectedCategory.id
      }, function (dishes) {
        vm.dishes = dishes;
      });
    });

    /**
     * Создание новой категории в модальном окне
     */

    categoryModal.on(categoryModal.events.create, function () {
      categories.fetchAll({}, function (categories) {
        vm.categories = categories;
      });
    });
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.admin.panel').run(appRun);

  /* @ngInject */
  function appRun(routehelper, USER_ROLES) {
    routehelper.configureRoutes(getRoutes(USER_ROLES));
  }

  function getRoutes(USER_ROLES) {
    return [{
      url: '/admin/panel',
      config: {
        templateUrl: 'html/components/admin/panel/panel.html',
        controller: 'Panel',
        controllerAs: 'panel',
        data: {
          authorities: [USER_ROLES.admin]
        }
      }
    }];
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.kitchen.orders').controller('Orders', Orders);

  Orders.$inject = ['$timeout', 'kitchen', 'helpers', 'toastr', 'APP_EVENTS', '$scope', '$q'];

  function Orders($timeout, kitchen, helpers, toastr, APP_EVENTS, $scope, $q) {
    var vm = this;

    vm.spinner = true;
    vm.orders = [];
    vm.makePrepared = makeOrderPrepared;
    vm.makeNotPrepared = makeOrderNotPrepared;
    vm.toggleDetailOrder = toggleDetailOrder;
    vm.findToggleOrder = findToggleOrder;
    vm.ordersLoad = false;

    // страшный костыль, из-за того нет сокетов.
    var toggleOrders = [];
    var statuses = {
      cooking: ['COOKING'],
      prepared: ['PREPARED']
    };

    $q.all([activate()]).then(function () {
      hideSpinner();
    });

    ////////////

    function activate() {
      return kitchen.fetchAll({}).$promise.then(function (orders) {
        vm.cooking = helpers.filterOrdersByStatus(orders, statuses.cooking).sort(helpers.compareById);
        vm.prepared = helpers.filterOrdersByStatus(orders, statuses.prepared).sort(helpers.compareById);

        makeToggleObjects(vm.cooking);
        makeToggleObjects(vm.prepared);

        vm.ordersLoad = true;
      });
    }

    function makeOrderPrepared(order) {
      var toggleObj = findToggleOrder(order);
      toggleObj.toggle = false;

      transferOrderInPrepared(order);

      kitchen.prepared({ id: order.id }, function () {
        toastr.success('Статус замовлення змінено');
      });
    }

    function makeOrderNotPrepared(order) {
      var toggleObj = findToggleOrder(order);
      toggleObj.toggle = false;

      transferOrderInCooking(order);

      kitchen.notPrepared({ id: order.id }, function () {
        toastr.success('Статус замовлення змінено');
      });
    }

    /**
     * Переносит заказ из статуса COOKING в PREPARED а так же сортирует
     * @param {Object} order
     */

    function transferOrderInPrepared(order) {
      vm.cooking.splice(vm.cooking.indexOf(order), 1);
      vm.prepared.push(order);
      vm.prepared.sort(helpers.compareById);
    }

    /**
     * Переносит заказ из статуса PREPARED в COOKING а так же сортирует
     * @param {Object} order
     */

    function transferOrderInCooking(order) {
      vm.prepared.splice(vm.prepared.indexOf(order), 1);
      vm.cooking.push(order);
      vm.cooking.sort(helpers.compareById);
    }

    function toggleDetailOrder(order) {
      var toggleObj = findToggleOrder(order);

      if (toggleObj) {
        toggleObj.toggle = !toggleObj.toggle;
      }
    }

    function hideSpinner() {
      $timeout(function () {
        vm.spinner = false;
      }, 400);
    }

    function findToggleOrder(order) {
      return helpers.searchByKey(toggleOrders, { id: order.id });
    }

    function makeToggleObjects(orders) {
      orders.forEach(function (order) {
        if (!findToggleOrder(order)) {
          toggleOrders.push({
            id: order.id,
            toggle: false
          });
        }
      });
    }

    /**
     * Обновление страницы
     */

    $scope.$on(APP_EVENTS.refreshPage, function () {
      $q.all([activate()]).then(function () {
        $scope.$emit(APP_EVENTS.refreshPageDone);
      });
    });
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.kitchen.orders').run(appRun);

  /* @ngInject */
  function appRun(routehelper, USER_ROLES) {
    routehelper.configureRoutes(getRoutes(USER_ROLES));
  }

  /* @ngInject */
  function getRoutes(USER_ROLES) {
    return [{
      url: '/kitchen/orders',
      config: {
        templateUrl: 'html/components/kitchen/orders/orders.html',
        controller: 'Orders',
        controllerAs: 'kitchen',
        data: {
          authorities: [USER_ROLES.kitchen]
        }
      }
    }];
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.manager.dashboard').controller('DashboardManager', DashboardManager);

  DashboardManager.$inject = ['orders', 'operator', 'APP_EVENTS', '$scope', '$q', 'helpers', 'managerOrderDetailModal', 'managerOrderDetailMiniModal'];

  /* @ngInject */
  function DashboardManager(orders, operator, APP_EVENTS, $scope, $q, helpers, orderDetailModal, orderDetailMiniModal) {
    var vm = this;

    vm.callCenter = [];
    vm.kitchen = [];
    vm.delivery = [];
    vm.ordersLoading = true;
    vm.showModalOrder = showModalOrder;
    vm.makeInProgress = makeInProgress;

    var selectedOrder = void 0;
    var modalFull = true;
    var statuses = {
      callCenter: ['FRESH', 'IN_PROGRESS'],
      kitchen: ['KITCHEN', 'COOKING', 'PREPARED'],
      delivery: ['DELIVERY', 'DONE']
    };

    activate();

    ////////////////

    function activate() {
      return orders.fetchAvailable({}).$promise.then(function (orders) {
        vm.callCenter = filterOrdersByStatus(orders, statuses.callCenter).sort(helpers.compareById);
        vm.kitchen = filterOrdersByStatus(orders, statuses.kitchen).sort(helpers.compareById);
        vm.delivery = filterOrdersByStatus(orders, statuses.delivery).sort(helpers.compareById);
        vm.ordersLoading = false;
      });
    }

    /**
     * Фильтрация всех заказов по переданным статусам
     * @param {Array} orders
     * @param {Array} statuses
     * @returns {Array}
     */

    function filterOrdersByStatus(orders, statuses) {
      var results = [];

      orders.forEach(function (order) {
        if (helpers.findString(statuses, order.status)) {
          results.push(order);
        }
      });

      return results;
    }

    /**
     * Модальное окно с детальной информацией о заказе
     * @param order
     */

    function showModalOrder(order, full) {
      selectedOrder = order;
      modalFull = full;

      if (selectedOrder.status === 'FRESH') {
        makeInProgress(selectedOrder);
      }

      var copy = angular.copy(selectedOrder);

      if (copy.timeToDeliver) {
        copy.timeToDeliver = helpers.parseDate(copy.timeToDeliver);
      }

      if (full) {
        orderDetailModal.scope.createEnabled = false;
        orderDetailModal.scope.order = copy;
        orderDetailModal.show();
      } else {
        orderDetailMiniModal.scope.order = copy;
        orderDetailMiniModal.show();
      }
    }

    function makeInProgress(order) {
      order.status = 'IN_PROGRESS';
      operator.makeInProgress({ id: order.id });
    }

    /**
     * Переносит заказ из колонки CALL центр в Кухню, а так же сортирует
     * @param {Object} order
     */

    function transferOrderInKitchen(order) {
      var search = helpers.searchByKey(vm.callCenter, { id: order.id });

      vm.callCenter.splice(vm.callCenter.indexOf(search), 1);
      vm.kitchen.push(order);
      vm.kitchen.sort(helpers.compareById);
    }

    /**
     * Обновление страницы
     */

    $scope.$on(APP_EVENTS.refreshPage, function () {
      $q.all([activate()]).then(function () {
        $scope.$emit(APP_EVENTS.refreshPageDone);
      });
    });

    /**
     * Оформление заказа в модальном окне
     */

    orderDetailModal.on(orderDetailModal.events.create, function (order) {
      vm.kitchen.push(order);
      vm.kitchen.sort(helpers.compareById);
    });

    /**
     * Обновление заказа в модальном окне
     */

    orderDetailModal.on(orderDetailModal.events.update, function (order) {
      transferOrderInKitchen(order);
    });

    /**
     * Отмена заказа в модальном окне
     */

    orderDetailModal.on(orderDetailModal.events.decline, function (order) {
      var search = helpers.searchByKey(vm.callCenter, { id: order.id });

      vm.callCenter.splice(vm.callCenter.indexOf(search), 1);
      vm.callCenter.sort(helpers.compareById);
    });

    /**
     * Не удалось доставить заказ
     */

    orderDetailMiniModal.on(orderDetailMiniModal.events.decline, function (order) {
      var search = helpers.searchByKey(vm.delivery, { id: order.id });

      vm.delivery.splice(vm.delivery.indexOf(search), 1);
      vm.delivery.sort(helpers.compareById);
    });
  }
})();
'use strict';

(function () {
  'use strict';

  angular.module('app.manager.dashboard').run(appRun);

  /* @ngInject */
  function appRun(routehelper, USER_ROLES) {
    routehelper.configureRoutes(getRoutes(USER_ROLES));
  }

  /* @ngInject */
  function getRoutes(USER_ROLES) {
    return [{
      url: '/manager/dashboard',
      config: {
        templateUrl: 'html/components/manager/dashboard/dashboard.html',
        controller: 'DashboardManager',
        controllerAs: 'dash',
        data: {
          authorities: [USER_ROLES.manager]
        }
      }
    }];
  }
})();
//# sourceMappingURL=bundle.min.js.map
